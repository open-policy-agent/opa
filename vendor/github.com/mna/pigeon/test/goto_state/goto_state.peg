{
// Package asmgotostate implements the asmgoto example with global state instead of GlobalStore.
//
// Very simplistic assembler language, only containing noop and jump instructions.
// Jump instructions use labels as target, which may be defined optionally on ever code line.
//
// The global state is used to keep track of the labels as well as the unresolved targets for jump instructions.
//
// Example:
//     label: noop
//     jump label
//
package asmgotostate

func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

Program ← #{ if _, ok := c.state["labelLookup"]; !ok { ll := make(labelLookup); c.state["labelLookup"] = ll; }; return nil } lines:Line* EOF &{ return labelCheck(c) } {
  lines0 := toIfaceSlice(lines)
  asmLines := make([]Instruction, 0, len(lines0))
  for _, line := range lines0 {
    asmLines = append(asmLines, line.(Instruction))
  }
  return asmLines, nil
}

Line ← _ inst:Instruction _ (nl / EOF) {
  return inst, nil
}

Instruction ← Label? _ op:( Noop / Jump ) {
  return op, nil
}

Label ← label:labelIdentifier #{ return addLabel(c, label.(string)) } ":"

labelIdentifier ← [a-z][a-z0-9]* {
  return string(c.text), nil
}

Noop ← "noop" {
  return Noop{}, nil
}

Jump ← "jump" __ label:labelIdentifier #{ return addJump(c, label.(string)) } {
  return getCurJump(c)
}

nl "newline" ← [\n\r]+

__ "whitespace" ← [ \t]+

_ "optional whitespace" ← [ \t]*

EOF ← !.