// Code generated by tools/cmd/genoptions/main.go. DO NOT EDIT.

package jws

import (
	"context"
	"io/fs"
	"sync"

	"github.com/lestrrat-go/option/v2"
)

type Option = option.Interface

// CompactOption describes options that can be passed to `jws.Compact`
type CompactOption interface {
	Option
	compactOption()
}

var compactOptionListPool = option.NewSetPool[CompactOption](
	&sync.Pool{New: func() any { return option.NewSet[CompactOption]() }},
)

func CompactOptionListPool() *option.SetPool[CompactOption] { return compactOptionListPool }

type compactOption struct {
	Option
}

func (*compactOption) compactOption() {}

// ReadFileOption is a type of `Option` that can be passed to `jwe.Parse`
type ParseOption interface {
	Option
	readFileOption()
}

var parseOptionListPool = option.NewSetPool[ParseOption](
	&sync.Pool{New: func() any { return option.NewSet[ParseOption]() }},
)

func ParseOptionListPool() *option.SetPool[ParseOption] { return parseOptionListPool }

type parseOption struct {
	Option
}

func (*parseOption) readFileOption() {}

// ReadFileOption is a type of `Option` that can be passed to `jws.ReadFile`
type ReadFileOption interface {
	Option
	readFileOption()
}

var readFileOptionListPool = option.NewSetPool[ReadFileOption](
	&sync.Pool{New: func() any { return option.NewSet[ReadFileOption]() }},
)

func ReadFileOptionListPool() *option.SetPool[ReadFileOption] { return readFileOptionListPool }

type readFileOption struct {
	Option
}

func (*readFileOption) readFileOption() {}

// SignOption describes options that can be passed to `jws.Sign`
type SignOption interface {
	Option
	signOption()
}

var signOptionListPool = option.NewSetPool[SignOption](
	&sync.Pool{New: func() any { return option.NewSet[SignOption]() }},
)

func SignOptionListPool() *option.SetPool[SignOption] { return signOptionListPool }

type signOption struct {
	Option
}

func (*signOption) signOption() {}

// SignVerifyCompactOption describes options that can be passed to either `jws.Verify`,
// `jws.Sign`, or `jws.Compact`
type SignVerifyCompactOption interface {
	Option
	signOption()
	verifyOption()
	compactOption()
	parseOption()
}

var signVerifyCompactOptionListPool = option.NewSetPool[SignVerifyCompactOption](
	&sync.Pool{New: func() any { return option.NewSet[SignVerifyCompactOption]() }},
)

func SignVerifyCompactOptionListPool() *option.SetPool[SignVerifyCompactOption] {
	return signVerifyCompactOptionListPool
}

type signVerifyCompactOption struct {
	Option
}

func (*signVerifyCompactOption) signOption() {}

func (*signVerifyCompactOption) verifyOption() {}

func (*signVerifyCompactOption) compactOption() {}

func (*signVerifyCompactOption) parseOption() {}

// SignVerifyOption describes options that can be passed to either `jws.Verify` or `jws.Sign`
type SignVerifyOption interface {
	Option
	signOption()
	verifyOption()
	parseOption()
}

var signVerifyOptionListPool = option.NewSetPool[SignVerifyOption](
	&sync.Pool{New: func() any { return option.NewSet[SignVerifyOption]() }},
)

func SignVerifyOptionListPool() *option.SetPool[SignVerifyOption] { return signVerifyOptionListPool }

type signVerifyOption struct {
	Option
}

func (*signVerifyOption) signOption() {}

func (*signVerifyOption) verifyOption() {}

func (*signVerifyOption) parseOption() {}

type SignVerifyParseOption interface {
	Option
	signOption()
	verifyOption()
	parseOption()
	readFileOption()
}

var signVerifyParseOptionListPool = option.NewSetPool[SignVerifyParseOption](
	&sync.Pool{New: func() any { return option.NewSet[SignVerifyParseOption]() }},
)

func SignVerifyParseOptionListPool() *option.SetPool[SignVerifyParseOption] {
	return signVerifyParseOptionListPool
}

type signVerifyParseOption struct {
	Option
}

func (*signVerifyParseOption) signOption() {}

func (*signVerifyParseOption) verifyOption() {}

func (*signVerifyParseOption) parseOption() {}

func (*signVerifyParseOption) readFileOption() {}

// VerifyOption describes options that can be passed to `jws.Verify`
type VerifyOption interface {
	Option
	verifyOption()
	parseOption()
}

var verifyOptionListPool = option.NewSetPool[VerifyOption](
	&sync.Pool{New: func() any { return option.NewSet[VerifyOption]() }},
)

func VerifyOptionListPool() *option.SetPool[VerifyOption] { return verifyOptionListPool }

type verifyOption struct {
	Option
}

func (*verifyOption) verifyOption() {}

func (*verifyOption) parseOption() {}

// JSONSuboption describes suboptions that can be passed to the `jws.WithJSON()` option.
type WithJSONSuboption interface {
	Option
	withJSONSuboption()
}

var withJSONSuboptionListPool = option.NewSetPool[WithJSONSuboption](
	&sync.Pool{New: func() any { return option.NewSet[WithJSONSuboption]() }},
)

func WithJSONSuboptionListPool() *option.SetPool[WithJSONSuboption] { return withJSONSuboptionListPool }

type withJSONSuboption struct {
	Option
}

func (*withJSONSuboption) withJSONSuboption() {}

// WithKeySetSuboption is a suboption passed to the `jws.WithKeySet()` option
type WithKeySetSuboption interface {
	Option
	withKeySetSuboption()
}

var withKeySetSuboptionListPool = option.NewSetPool[WithKeySetSuboption](
	&sync.Pool{New: func() any { return option.NewSet[WithKeySetSuboption]() }},
)

func WithKeySetSuboptionListPool() *option.SetPool[WithKeySetSuboption] {
	return withKeySetSuboptionListPool
}

type withKeySetSuboption struct {
	Option
}

func (*withKeySetSuboption) withKeySetSuboption() {}

// WithKeySuboption describes option types that can be passed to the `jws.WithKey()`
// option.
type WithKeySuboption interface {
	Option
	withKeySuboption()
}

var withKeySuboptionListPool = option.NewSetPool[WithKeySuboption](
	&sync.Pool{New: func() any { return option.NewSet[WithKeySuboption]() }},
)

func WithKeySuboptionListPool() *option.SetPool[WithKeySuboption] { return withKeySuboptionListPool }

type withKeySuboption struct {
	Option
}

func (*withKeySuboption) withKeySuboption() {}

type identBase64Encoder struct{}
type identContext struct{}
type identDetached struct{}
type identDetachedPayload struct{}
type identFS struct{}
type identInferAlgorithmFromKey struct{}
type identKey struct{}
type identKeyProvider struct{}
type identKeyUsed struct{}
type identMessage struct{}
type identMultipleKeysPerKeyID struct{}
type identPretty struct{}
type identProtectedHeaders struct{}
type identPublicHeaders struct{}
type identRequireKid struct{}
type identSerialization struct{}
type identUseDefault struct{}
type identValidateKey struct{}

func (identBase64Encoder) String() string {
	return "WithBase64Encoder"
}

func (identContext) String() string {
	return "WithContext"
}

func (identDetached) String() string {
	return "WithDetached"
}

func (identDetachedPayload) String() string {
	return "WithDetachedPayload"
}

func (identFS) String() string {
	return "WithFS"
}

func (identInferAlgorithmFromKey) String() string {
	return "WithInferAlgorithmFromKey"
}

func (identKey) String() string {
	return "WithKey"
}

func (identKeyProvider) String() string {
	return "WithKeyProvider"
}

func (identKeyUsed) String() string {
	return "WithKeyUsed"
}

func (identMessage) String() string {
	return "WithMessage"
}

func (identMultipleKeysPerKeyID) String() string {
	return "WithMultipleKeysPerKeyID"
}

func (identPretty) String() string {
	return "WithPretty"
}

func (identProtectedHeaders) String() string {
	return "WithProtectedHeaders"
}

func (identPublicHeaders) String() string {
	return "WithPublicHeaders"
}

func (identRequireKid) String() string {
	return "WithRequireKid"
}

func (identSerialization) String() string {
	return "WithSerialization"
}

func (identUseDefault) String() string {
	return "WithUseDefault"
}

func (identValidateKey) String() string {
	return "WithValidateKey"
}

// WithBase64Encoder specifies the base64 encoder to be used while signing or
// verifying the JWS message. By default, the raw URL base64 encoding (no padding)
// is used.
func WithBase64Encoder(v Base64Encoder) SignVerifyCompactOption {
	return &signVerifyCompactOption{option.New(identBase64Encoder{}, v)}
}

func WithContext(v context.Context) VerifyOption {
	return &verifyOption{option.New(identContext{}, v)}
}

var trueWithDetached = &compactOption{option.New(identDetached{}, true)}
var falseWithDetached = &compactOption{option.New(identDetached{}, false)}

// WithDetached specifies that the `jws.Message` should be serialized in
// JWS compact serialization with detached payload. The resulting octet
// sequence will not contain the payload section.
func WithDetached(v bool) CompactOption {
	if v {
		return trueWithDetached
	}
	return falseWithDetached
}

// WithDetachedPayload can be used to both sign or verify a JWS message with a
// detached payload.
// Note that this option does NOT populate the `b64` header, which is sometimes
// required by other JWS implementations.
//
// When this option is used for `jws.Sign()`, the first parameter (normally the payload)
// must be set to `nil`.
//
// If you have to verify using this option, you should know exactly how and why this works.
func WithDetachedPayload(v []byte) SignVerifyOption {
	return &signVerifyOption{option.New(identDetachedPayload{}, v)}
}

// WithFS specifies the source `fs.FS` object to read the file from.
func WithFS(v fs.FS) ReadFileOption {
	return &readFileOption{option.New(identFS{}, v)}
}

var trueWithInferAlgorithmFromKey = &withKeySetSuboption{option.New(identInferAlgorithmFromKey{}, true)}
var falseWithInferAlgorithmFromKey = &withKeySetSuboption{option.New(identInferAlgorithmFromKey{}, false)}

// WithInferAlgorithmFromKey specifies whether the JWS signing algorithm name
// should be inferred by looking at the provided key, in case the JWS
// message or the key does not have a proper `alg` header.
//
// When this option is set to true, a list of algorithm(s) that is compatible
// with the key type will be enumerated, and _ALL_ of them will be tried
// against the key/message pair. If any of them succeeds, the verification
// will be considered successful.
//
// Compared to providing explicit `alg` from the key this is slower, and
// verification may fail to verify if somehow our heuristics are wrong
// or outdated.
//
// Also, automatic detection of signature verification methods are always
// more vulnerable for potential attack vectors.
//
// It is highly recommended that you fix your key to contain a proper `alg`
// header field instead of resorting to using this option, but sometimes
// it just needs to happen.
func WithInferAlgorithmFromKey(v bool) WithKeySetSuboption {
	if v {
		return trueWithInferAlgorithmFromKey
	}
	return falseWithInferAlgorithmFromKey
}

func WithKeyProvider(v KeyProvider) VerifyOption {
	return &verifyOption{option.New(identKeyProvider{}, v)}
}

// WithKeyUsed allows you to specify the `jws.Verify()` function to
// return the key used for verification. This may be useful when
// you specify multiple key sources or if you pass a `jwk.Set`
// and you want to know which key was successful at verifying the
// signature.
//
// `v` must be a pointer to an empty `interface{}`. Do not use
// `jwk.Key` here unless you are 100% sure that all keys that you
// have provided are instances of `jwk.Key` (remember that the
// jwx API allows users to specify a raw key such as *rsa.PublicKey)
func WithKeyUsed(v interface{}) VerifyOption {
	return &verifyOption{option.New(identKeyUsed{}, v)}
}

// WithMessage can be passed to Verify() to obtain the jws.Message upon
// a successful verification.
func WithMessage(v *Message) VerifyOption {
	return &verifyOption{option.New(identMessage{}, v)}
}

var trueWithMultipleKeysPerKeyID = &withKeySetSuboption{option.New(identMultipleKeysPerKeyID{}, true)}
var falseWithMultipleKeysPerKeyID = &withKeySetSuboption{option.New(identMultipleKeysPerKeyID{}, false)}

// WithMultipleKeysPerKeyID specifies if we should expect multiple keys
// to match against a key ID. By default it is assumed that key IDs are
// unique, i.e. for a given key ID, the key set only contains a single
// key that has the matching ID. When this option is set to true,
// multiple keys that match the same key ID in the set can be tried.
func WithMultipleKeysPerKeyID(v bool) WithKeySetSuboption {
	if v {
		return trueWithMultipleKeysPerKeyID
	}
	return falseWithMultipleKeysPerKeyID
}

var trueWithPretty = &withJSONSuboption{option.New(identPretty{}, true)}
var falseWithPretty = &withJSONSuboption{option.New(identPretty{}, false)}

// WithPretty specifies whether the JSON output should be formatted and
// indented
func WithPretty(v bool) WithJSONSuboption {
	if v {
		return trueWithPretty
	}
	return falseWithPretty
}

// WithProtected is used with `jws.WithKey()` option when used with `jws.Sign()`
// to specify a protected header to be attached to the JWS signature.
//
// It has no effect if used when `jws.WithKey()` is passed to `jws.Verify()`
func WithProtectedHeaders(v Headers) WithKeySuboption {
	return &withKeySuboption{option.New(identProtectedHeaders{}, v)}
}

// WithPublic is used with `jws.WithKey()` option when used with `jws.Sign()`
// to specify a public header to be attached to the JWS signature.
//
// It has no effect if used when `jws.WithKey()` is passed to `jws.Verify()`
//
// `jws.Sign()` will result in an error if `jws.WithPublic()` is used
// and the serialization format is compact serialization.
func WithPublicHeaders(v Headers) WithKeySuboption {
	return &withKeySuboption{option.New(identPublicHeaders{}, v)}
}

var trueWithRequireKid = &withKeySetSuboption{option.New(identRequireKid{}, true)}
var falseWithRequireKid = &withKeySetSuboption{option.New(identRequireKid{}, false)}

// WithRequiredKid specifies whether the keys in the jwk.Set should
// only be matched if the target JWS message's Key ID and the Key ID
// in the given key matches.
func WithRequireKid(v bool) WithKeySetSuboption {
	if v {
		return trueWithRequireKid
	}
	return falseWithRequireKid
}

var valWithCompact = &signVerifyParseOption{option.New(identSerialization{}, fmtCompact)}

// WithCompact specifies that the result of `jws.Sign()` is serialized in
// compact format.
//
// By default `jws.Sign()` will opt to use compact format, so you usually
// do not need to specify this option other than to be explicit about it
func WithCompact() SignVerifyParseOption {
	return valWithCompact
}

var trueWithUseDefault = &withKeySetSuboption{option.New(identUseDefault{}, true)}
var falseWithUseDefault = &withKeySetSuboption{option.New(identUseDefault{}, false)}

// WithUseDefault specifies that if and only if a jwk.Key contains
// exactly one jwk.Key, that key should be used.
func WithUseDefault(v bool) WithKeySetSuboption {
	if v {
		return trueWithUseDefault
	}
	return falseWithUseDefault
}

var trueWithValidateKey = &signVerifyOption{option.New(identValidateKey{}, true)}
var falseWithValidateKey = &signVerifyOption{option.New(identValidateKey{}, false)}

// WithValidateKey specifies whether the key used for signing or verification
// should be validated before using. Note that this means calling
// `key.Validate()` on the key, which in turn means that your key
// must be a `jwk.Key` instance, or a key that can be converted to
// a `jwk.Key` by calling `jwk.Import()`. This means that your
// custom hardware-backed keys will probably not work.
//
// You can directly call `key.Validate()` yourself if you need to
// mix keys that cannot be converted to `jwk.Key`.
//
// Please also note that use of this option will also result in
// one extra conversion of raw keys to a `jwk.Key` instance. If you
// care about shaving off as much as possible, consider using a
// pre-validated key instead of using this option to validate
// the key on-demand each time.
//
// By default, the key is not validated.
func WithValidateKey(v bool) SignVerifyOption {
	if v {
		return trueWithValidateKey
	}
	return falseWithValidateKey
}
