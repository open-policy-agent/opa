---
cases:
  - note: string-interpolation/empty string
    modules:
      - |
        package test

        p := $""
    query: data.test.p = x
    want_result:
      - x: ""
  - note: string-interpolation/no template expression
    modules:
      - |
        package test

        p := $"foo bar baz"
    query: data.test.p = x
    want_result:
      - x: "foo bar baz"
  - note: string-interpolation/escaped template expressions
    modules:
      - |
        package test

        a := $"\{42}"
        b := $"foo \{42} bar"
        c := $"foo \{42\}"
        d := $"foo \{42\} bar"
        e := $"foo \{42} bar \{43} baz"
        f := $"\{{42}"
        g := $"{42}\}"
    query: data.test = x
    want_result:
      - x:
          a: "{42}"
          b: "foo {42} bar"
          c: "foo {42}"
          d: "foo {42} bar"
          e: "foo {42} bar {43} baz"
          f: "{42"
          g: "42}"
  - note: string-interpolation/template expressions with primitive values
    modules:
      - |
        package test

        p := $"{42}, {13.37}, {true}, {"foo"}, {null}"
    query: data.test.p = x
    want_result:
      - x: "42, 13.37, true, foo, null"
  - note: string-interpolation/template expressions with collection values
    modules:
      - |
        package test

        p := $"{[42, 13.37, true, "foo", null]}, {{42, 13.37, true, "foo", null}}, {{"a": "b"}}"
    query: data.test.p = x
    want_result:
      - x: "[42, 13.37, true, \"foo\", null], {null, true, 13.37, 42, \"foo\"}, {\"a\": \"b\"}"
  - note: string-interpolation/template expression with array comprehension
    modules:
      - |
        package test
        
        a := ["a", "b", "c"]

        p := $"{[x | some x in a]}"
    query: data.test.p = x
    want_result:
      - x: "[\"a\", \"b\", \"c\"]"
  - note: string-interpolation/template expression with set comprehension
    modules:
      - |
        package test
        
        a := ["a", "b", "c"]

        p := $"{{x | some x in a}}"
    query: data.test.p = x
    want_result:
      - x: "{\"a\", \"b\", \"c\"}"
  - note: string-interpolation/template expression with object comprehension
    modules:
      - |
        package test
        
        a := ["a", "b", "c"]

        p := $"{{x: x | some x in a}}"
    query: data.test.p = x
    want_result:
      - x: "{\"a\": \"a\", \"b\": \"b\", \"c\": \"c\"}"
  - note: string-interpolation/template expressions with variables
    modules:
      - |
        package test

        a := "foo"
        b := "bar"

        p := $"{a} {b}"
    query: data.test.p = x
    want_result:
      - x: "foo bar"
  - note: string-interpolation/template expressions with refs
    modules:
      - |
        package test

        a := "foo"

        p := $"{data.test.a} {data.b} {input.c}"
    data:
      b: "bar"
    input:
      c: "baz"
    query: data.test.p = x
    want_result:
      - x: "foo bar baz"
  - note: string-interpolation/nested template expressions
    modules:
      - |
        package test

        a := "foo"
        b := "bar"

        p := $"{$"{a}"} {$"{$"{b}"} baz"}"
    query: data.test.p = x
    want_result:
      - x: "foo bar baz"
  - note: string-interpolation/nested template expressions, undefined outer expression
    modules:
      - |
        package test

        p := $"{$"{data.a}"} {$"{$"{data.b}"} baz"}"
    data:
      b: "bar"
    query: data.test.p = x
    want_result:
      - x: "<undefined> bar baz"
  - note: string-interpolation/nested template expressions, undefined inner expression
    modules:
      - |
        package test

        p := $"{$"{data.a}"} {$"{$"{data.b}"} baz"}"
    data:
      a: "foo"
    query: data.test.p = x
    want_result:
      - x: "foo <undefined> baz"
  - note: string-interpolation/template expressions with infix operand call
    modules:
      - |
        package test

        a := 42
        b := {"a", "b", "c"}

        p := $"sum: {1 + 42}, join: {b | {"d", "e", "f"}}"
    query: data.test.p = x
    want_result:
      - x: 'sum: 43, join: {"a", "b", "c", "d", "e", "f"}'
  - note: string-interpolation/template expressions with undefined values
    modules:
      - |
        package test

        p := $"{input.x}, {data.y}"
    query: data.test.p = x
    want_result:
      - x: "<undefined>, <undefined>"
  - note: string-interpolation/inside array comprehension
    modules:
      - |
        package test

        a := ["foo", "bar"]

        p := [x | some y in a; x := $"<{y}>"]
    query: data.test.p = x
    want_result:
      - x:
        - "<foo>"
        - "<bar>"
  - note: string-interpolation/inside set comprehension
    modules:
      - |
        package test

        a := "foo"

        # Only generate one entry to avoid non-deterministic ordering.
        p := {x | x = $"<{a}>"}
    query: data.test.p = x
    want_result:
      - x:
        - "<foo>"
  - note: string-interpolation/inside map comprehension
    modules:
      - |
        package test

        a := ["foo", "bar"]

        p := {x: y | some k, v in a; x = $"<{k}>"; y = $"<{v}>"}
    query: data.test.p = x
    want_result:
      - x:
          "<0>": "<foo>"
          "<1>": "<bar>"
  - note: string-interpolation/inside map comprehension head
    modules:
      - |
        package test

        a := ["foo", "bar"]

        p := {$"<{k}>": $"<{v}>" | some k, v in a}
    query: data.test.p = x
    want_result:
      - x:
          "<0>": "<foo>"
          "<1>": "<bar>"
  - note: string-interpolation/inside every expression, body
    modules:
      - |
        package test
        p if {
          every i, x in input.l1 {
            input.l2[i] == $"<{x}>"
          }
        }
    input:
      l1:
        - "a"
        - "b"
        - "c"
      l2:
        - "<a>"
        - "<b>"
        - "<c>"
    query: data.test.p = x
    want_result:
      - x: true
  - note: string-interpolation/with in template expression
    modules:
      - |
        package test
        
        a := input.a

        p := x if {
          x := $"foo {a with input as {"a" : 42}}"
        }
    query: data.test.p = x
    want_result:
      - x: "foo 42"
  - note: string-interpolation/with outside template string
    modules:
      - |
        package test
        
        a := input.a
        b := input.b

        p := x if {
          x := $"foo {a} {b}" 
            with input.a as 42
            with input.b as "bar"
        }
    query: data.test.p = x
    want_result:
      - x: "foo 42 bar"
  - note: string-interpolation/with outside template string, overrides
    modules:
      - |
        package test
        
        a := input.a
        b := input.b

        p := x if {
          x := $"foo {a} {b}" 
            with input as {"a" : 42}
            with input as {"b" : "bar"} # overrides above 'with', dropping the 'a' field
        }
    query: data.test.p = x
    want_result:
      - x: "foo <undefined> bar"
  - note: string-interpolation/var declared after template-string
    modules:
      - |
        package test
        
        p := msg if { 
            msg = $"foo {x + 2} bar"
            x = 7
        }
    query: data.test.p = x
    want_result:
      - x: "foo 9 bar"
  - note: string-interpolation/template-string function arg
    modules:
      - |
        package test

        p := f("foo bar")

        f($"{x} {input.y}") := 42 if {
            x = "foo"
        }
    input:
      "y": "bar"
    query: data.test.p = x
    want_result:
      - x: 42