---
title: Glob Matching
---
<BuiltinTable category={"glob"}/>

## Overview

The `glob.match` function matches strings against glob patterns with optional delimiters.

## Delimiter Requirements

Delimiters must be **single characters**. Each delimiter in the array must be exactly one character long.

```rego title="Valid delimiters"
glob.match("a:*", [":"], "a:b")          # ✓ Single character
glob.match("a/b.c", ["/", "."], "a/b.c") # ✓ Multiple single characters
```

```rego title="Invalid delimiters"
glob.match("a::*", ["::"], "a::b")   # ✗ Multi-character delimiter (error)
glob.match("a:*", [""], "a:b")       # ✗ Empty string delimiter (error)
```

Delimiters are used to split the input into segments for matching. Each delimiter must be exactly one character to unambiguously identify segment boundaries. Using multi-character strings would create ambiguity in parsing.

If you provide multi-character or empty delimiters, `glob.match` will return `undefined` (or an error with `--strict-builtin-errors` enabled).

An empty array `[]` defaults to `"."` (dot) as the delimiter:

```rego title="Default delimiter"
glob.match("*.github.com", [], "api.github.com")  # uses "." delimiter
```

Using `null` means no delimiters are used:

```rego title="No delimiters"
glob.match("*hub.com", null, "api.cdn.github.com")  # no segmentation
```

## Multiple Delimiters

You can specify multiple single-character delimiters to match paths with different separators.

<PlaygroundExample path="glob/multiple_delimiters" title="Multiple Delimiters" />

## Indexing Considerations

For `glob.match` to benefit from indexing optimizations, the pattern must contain the delimiter character(s). For example, `glob.match("a:*", [":"], input.x)` will be indexed because the pattern `"a:*"` contains the delimiter `":"`. However, `glob.match("a*", [":"], input.x)` will not be indexed because the pattern `"a*"` does not contain the delimiter. Similarly, `glob.match("foo*", null, input.x)` cannot be indexed because `null` delimiters have no character to match in the pattern.

Non-indexed patterns still work correctly but may be slower on large datasets. See the [Policy Performance](../../policy-performance#glob-statements) guide for more details.

## Examples

The following table shows examples of how `glob.match` works:

| `call`                                                           | `output` | Description                                   |
| ---------------------------------------------------------------- | -------- | --------------------------------------------- |
| `output := glob.match("*.github.com", [], "api.github.com")`     | `true`   | A glob with the default `["."]` delimiter.    |
| `output := glob.match("*.github.com", [], "api.cdn.github.com")` | `false`  | A glob with the default `["."]` delimiter.    |
| `output := glob.match("*hub.com", null, "api.cdn.github.com")`   | `true`   | A glob without delimiter.                     |
| `output := glob.match("*:github:com", [":"], "api:github:com")`  | `true`   | A glob with delimiters `[":"]`.               |
| `output := glob.match("api.**.com", [], "api.github.com")`       | `true`   | A super glob.                                 |
| `output := glob.match("api.**.com", [], "api.cdn.github.com")`   | `true`   | A super glob.                                 |
| `output := glob.match("?at", [], "cat")`                         | `true`   | A glob with a single character wildcard.      |
| `output := glob.match("?at", [], "at")`                          | `false`  | A glob with a single character wildcard.      |
| `output := glob.match("[abc]at", [], "bat")`                     | `true`   | A glob with character-list matchers.          |
| `output := glob.match("[abc]at", [], "cat")`                     | `true`   | A glob with character-list matchers.          |
| `output := glob.match("[abc]at", [], "lat")`                     | `false`  | A glob with character-list matchers.          |
| `output := glob.match("[!abc]at", [], "cat")`                    | `false`  | A glob with negated character-list matchers.  |
| `output := glob.match("[!abc]at", [], "lat")`                    | `true`   | A glob with negated character-list matchers.  |
| `output := glob.match("[a-c]at", [], "cat")`                     | `true`   | A glob with character-range matchers.         |
| `output := glob.match("[a-c]at", [], "lat")`                     | `false`  | A glob with character-range matchers.         |
| `output := glob.match("[!a-c]at", [], "cat")`                    | `false`  | A glob with negated character-range matchers. |
| `output := glob.match("[!a-c]at", [], "lat")`                    | `true`   | A glob with negated character-range matchers. |
| `output := glob.match("{cat,bat,[fr]at}", [], "cat")`            | `true`   | A glob with pattern-alternatives matchers.    |
| `output := glob.match("{cat,bat,[fr]at}", [], "bat")`            | `true`   | A glob with pattern-alternatives matchers.    |
| `output := glob.match("{cat,bat,[fr]at}", [], "rat")`            | `true`   | A glob with pattern-alternatives matchers.    |
| `output := glob.match("{cat,bat,[fr]at}", [], "at")`             | `false`  | A glob with pattern-alternatives matchers.    |
