# Rego: OPA's Query Language

OPA includes a policy engine that is purpose built for reasoning about information represented in structured documents such as JSON. Data stored in in the policy engine can be queried using OPA's native query language: Rego.

## What is Rego?

Rego was inspired by [Datalog](https://en.wikipedia.org/wiki/Datalog), which is a well understood, decades old query language. Rego extends Datalog to support structured document models such as JSON.

Rego queries are assertions on data stored in OPA. These queries can be used to define policies that enumerate instances of data that violate the expected state of the system.

## Why use Rego?

Use Rego for defining policy that is easy to read and write.

Rego focuses on providing powerful support for referencing nested documents and ensuring that queries are correct and unambiguous.

Rego is declarative so policy authors can focus on what queries should return rather than how queries should be executed. These queries are simpler and more concise than the equivalent in an imperative language. Like other applications which support declarative query languages, OPA is able to optimize queries to improve performance, e.g., indexing, concurrent evaluation, reordering, etc.

## The Basics

This section introduces the main aspsects of Rego.

The simplest rule is a single expression and is defined in terms of a [Scalar Value](#scalar-values):

```rego
pi = 3.14159
```

Rules define the content of documents. We can query for the content of the "pi" document generated by the rule above:

```
pi
# 3.14159
```

Rules can also be defined in terms of [Composite Values](#composite-values):

```rego
rect = {"width": 2, "height": 4}
```

The result:

```
rect
# {"width": 2, "height": 4}
```

Many expressions are defined in terms of [Equality](#equality). These expressions can be thought of as assertions. The simplest example of a rule containing an equality expression involves two scalar values:

```rego
v :- 42 = "the meaning of life"
```

If we query for the contents of "v" we see the expression has been evaluated:

```
v
# false
```

The order of operands in an equality expression does not matter:

```rego
u :- "the meaning of life" = 42
```

The result is the same:

```
u
# false
```

We can define rules in terms of [Variables](#variables) as well:

```rego
t :- x = 42, y = 41, x > y
```

Multiple expressions are separated by the comma (",") character. In order for the rule to be true, all of the expressions in the rule must true for some set of variable bindings. There may be multiple sets of variable bindings that make the rule true. The body of a rule can be understood intuitively as "\<expression-1> AND \<expression-2> AND ... AND \<expression-N>". The rule itself can be understood intuitively as "\<rule-name> is true if \<body>".

When we query for the contents of "t" we see the obvious result:

```
t
# true
```

The order of expressions in a rule does not affect the document's content:

```rego
s :- x > y, y = 41, x = 42
```

The query result is the same:

```
s
# true
```

Rego supports [References](#references) to nested documents. For example:

```rego
sites = [{"name": "prod"}, {"name": "smoke1"}, {"name": "dev"}]
r :- sites[i].name = "prod"
```

The rule "r" above asserts that there exists (at least) one document within "sites" where the "name" attribute equals "prod".

The result:

```
r
# true
```

We can generalize the example above with a rule that defines a set document instead of a boolean document:

```rego
sites = [{"name": "prod"}, {"name": "smoke1"}, {"name": "dev"}]
q[name] :- sites[i].name = name
```

When we query for "q" we obtain a set of names:

```
q
# ["prod", "smoke1", "dev"]
```

We can re-write the rule "r" from above to make use of "q". We will call the new rule "p":

```rego
p :- q["prod"]
```

The result will be the same:

```
p
# true
```

Rules which have arguments can be queried with input values:

```
q["smoke2"]
# false

q["dev"]
# true
```

If you made it this far, congratulations. This section introduced the main
aspects of Rego. The rest of this document describes the individual aspects of Rego in detail and is useful as a reference when reading and writing policy. Rego's syntax is defined at the end of this document in the [Rego Grammar](#grammar) section.

## <a name="scalar-values"></a> Scalar Values

Scalar values are the simplest type of term in Rego. Scalar values can be
strings, numbers, booleans, or null.

Documents can be defined solely in terms of scalar values. This is useful for
defining constants that are referenced in multiple places. For example:

```rego
greeting   = "Hello"
max_height = 42
pi         = 3.14159
allowed    = true
sentinel   = null
```

These documents can be queried like any other:

```
greeting
# "foo"

max_height
# 42

pi
# 3.14159

allowed
# true

sentinel
# null
```

## <a name="composite-values"></a> Composite Values

Composite values define collections. In simple cases, composite values
can be treated as constants like [Scalar Values](#scalar-values):

```rego
cube = {"width": 3, "height": 4, "depth": 5}
```

The result:

```
cube.width
# 3
```

Composite values can also be defined in terms of [Variables](#variables) or
[References](#references). For example:

```rego
p[x] :-
  foo = 42,
  bar = false,
  baz = null,
  x = {"foo": foo, "bar": [bar, baz]}
```

The result:

```
p
# [{"foo": 42, "bar": [false, null]}]
```

By defining composite values in terms of variables and references, rules can
define abstractions over raw data and other rules.

## <a name="variables"></a> Variables

Variables are another kind of term in Rego. They can appear in both the
head and body of rules.

Variables appearing in the head of a rule can be thought of as input and
output of the rule. Unlike many programming languages, where a variable is either an input or an output, in Rego a variable is simultaneously an input and an output. If a query supplies a value for a variable, that variable is an input, and if the query does not supply a value for a variable, that variable is an output.

For example:

```rego
sites = [{"name": "prod"}, {"name": "smoke1"}, {"name": "dev"}]
q[name] :- sites[i].name = name
```

In this case, if we evaluate "q" without providing an input value for "name" we obtain the names of all of the sites:

```
q
# ["prod", "smoke1", "dev"]
```

On the other hand, if we evaluate "q" with an input value for "name" we can determine whether "name" exists in the document defined by "q":

```
q["smoke2"]
# false

q["dev"]
# true
```

Variables appearing in the head of a rule must also appear in a non-negated
equality expression within the same rule. This property ensures that if the
rule is evaluated and all of the expressions evaluate to true for some set of
variable bindings, the variable in the head of the rule will be defined.

## <a name="references"></a> References

Referenced are used to access nested documents.

The examples in this section use the data defined in the [Examples](#examples)
section.

The simplest reference contains no variables. For example, the following
reference returns the hostname of the second server in the first site document
from our example data:

```
sites[0].servers[1].hostname
# "helium"
```

References are typically written using the "dot-access" style. The canonical form does away with "." and closely resembles dictionary lookup in a language such as Python:

```
sites[0]["servers"][1]["hostname"]
# "helium"
```

Both forms are valid, however, the "dot-access" style is typically more readable. Note, there are two cases where brackets need to be used:

1. String keys containing characters other than [a-z], [A-Z], [0-9], or "_" (underscore).
1. Non-string keys such as numbers, booleans, and null.
1. Variable keys which are described later.

References are always prefixed with a variable that identifes the root
document. In the example above this is "p". The root document may be:

- a local variable inside a rule.
- a rule inside the same package.
- a document stored in OPA.
- a documented temporarily provided to OPA as part of a transaction.

### Variable Keys

References can include variables as keys. References written this way are used to select a value from every element in a collection.

The following reference will select the hostnames of all the servers in our
example data:

```
sites[i].servers[j].hostname
# ["hydrogen", "helium", "lithium", "berylium", "boron"]
```

Conceptually, this is the same as the following imperative code (Python):

```python
def hostnames(sites):
    result = []
    for site in sites:
        for server in site.servers:
            result.append(server.hostname)
    return result
```

In the reference above, we effectively used variables named "i" and "j" to iterate the collections. If the variables are unused outside the reference, we prefer to replace them with an underscore ("_") character. The reference above can be rewritten as:

```
sites[_].servers[_].hostname
# ["hydrogen", "helium", "lithium", "berylium", "boron"]
```

The underscore is special because it cannot be referred to by other parts of the rule, e.g., the other side of the expression, another expression, etc. The underscore can be thought of as a special iterator. Each time an underscore is specified, a new iterator is instantiated.

> Under the hood, OPA translates the "_" character to a unique variable name that does not conflict with variables and rules that are in scope.

### Multiple Expressions

Rules are often written in terms of multiple expressions that contain references to documents. In the following example, the rule defines a set of tuples where each tuple contains an application name and a hostname of a server where the application is deployed.

```rego
apps_and_hostnames[pair] :-
    apps[i].name = name,
    apps[i].servers[_] = server,
    sites[j].servers[k].name = server,
    sites[j].servers[k].hostname = hostname,
    pair = [name, hostname]
```

The result:

```
apps_and_hostnames
# [
#   ["web", "hydrogen"],
#   ["web", "helium"],
#   ["web", "berylium"],
#   ["web", "boron"],
#   ["web", "nitrogen"],
#   ["mysql", "lithium"],
#   ["mysql", "carbon"],
#   ["mongodb", "oxygen"]
# ]
```

Don't worry about understanding everything in this example right now. There are just two important points:

1. Several variables appear more than once in the body. When a variable is used in multiple locations, OPA will only produce documents for the rule with the variable bound to the same value in all expressions.

2. The rule is joining the "apps" and "sites" documents implicitly. In Rego (and other languages based on Datalog) joins are implicit.

### Self-Joins

Using a different key on the same array or object provides the equivalent of self-join in SQL. For example, the following rule defines a document containing apps deployed on the same site as "mysql":

```rego
same_site[name] :-
    apps[i].name = "mysql",
    apps[i].servers[_] = server,
    sites[j].servers[_].name = server,
    sites[j].servers[_].name = other_server,
    server != other_server,
    apps[k].servers[_] = other_server,
    apps[k].name = name
```

The result:

```
same_site
# ["web", "web", "web", "web"]
```

## Rules

Rules define the content of [Virtual Documents](./CONTENT.md#data-model) in
OPA. When OPA evaluates a rule, we say OPA *generates* the content of the
document that is defined by the rule.

The examples in this section make use of the data defined
in the [Examples](#examples) section.

### <a name="set-documents"></a> Generating Sets

The following rule documents a set containing the hostnames of all servers:

```rego
hostnames[name] :- sites[_].servers[_].hostname = name
```

When we query for the content of "hostnames" we see the same data as we would if we queried using the `sites[_].servers[_].hostname` reference directly:

```
hostnames
# [
#   "hydrogen",
#   "helium",
#   "lithium",
#   "berylium",
#   "boron",
#   "carbon",
#   "nitrogen",
#   "oxygen"
# ]
```

This example introduces a few important aspects of Rego.

First, the rule defines a set document where the contents are defined by the
variable "name". We know this rule defines a set document because the head only includes a key. All rules have the following form (where key, value, and body are all optional):

```
<name> <key>? <value>? <body>?
```

For a more formal definition of the rule syntax, see the [Rego Grammar](#grammar) section at the end of this document.

> Set documents are collections of values without keys. OPA represents set documents as arrays when serializing to JSON or other formats which do not support a set data type. The important distinction between sets and arrays or objects is that sets are unkeyed while arrays and objects are keyed, i.e., you cannot refer to the index of an element within a set.

Second, the `sites[_].servers[_].hostname` fragment selects the "hostname" attribute from all of the objects in the "servers" collection. From reading the fragment in isolation we cannot tell whether the fragment refers to arrays or objects. We only know that it refers to a collections of values.

Third, the `sites[_].servers[_].hostname = name` expression binds the value of the "hostname" attribute to the variable "name", which is also declared in the head of the rule.

### <a name="object-documents"></a> Generating Objects

Rules that define objects are very similar to rules that define sets.

```rego
apps_by_hostname[hostname] = app :-
    sites[_].servers[_] = server,
    server.hostname = hostname,
    apps[i].servers[_] = server.name,
    apps[i].name = app
```

The rule above defines an object that maps hostnames to app names. The main
difference between this rule and one which defines a set is the rule head: in
addition to declaring a value, the rule head also declares a key for the
document.

The result:

```
apps_by_hostname["helium"]
# "web"
```

### <a name="incremental-definitions"></a> Incremental Definitions

A rule may be defined multiple times with the same name. When a rule is
defined this way, we refer to the rule definition as *incremental* because
each definition is additive. The document content for an incrementally defined
rule is the union of the document content for each of the individual rules.

For example, we can write a rule that abstracts over our "servers" and
"containers" data as "instances":

```rego
instances[instance] :-
    sites[_].servers[_] = server,
    instance = {"address": server.hostname, "name": server.name}

instances[instance] :-
    containers[_] = container,
    instance = {"address": container.ipaddress, "name": container.name}
```

An incrementally defined rule can be intuitively understood as "\<rule-1> OR
\<rule-2> OR ... OR \<rule-N>".

## <a name="negation"></a> Negation

To generate the content of a [Virtual Document](./CONCEPTS.md#data-model), OPA attempts to bind variables in the body of the rule such that all expressions in the rule evaluate to True.

This generates the correct result when the expressions represent assertions about what states should exist in the data stored in OPA. In some cases, you want to express that certain states *should not* exist in the data stored in OPA. In these cases, negation must be used.

For safety, a variable appearing in a negated expression must also appear in another non-negated equality expression in the rule.

> OPA will reorder expressions to ensure that negated expressions are evaluated after other non-negated expressions with the same variables. OPA will reject rules containing negated expressions that do not meet the safety criteria described above.

The simplest use of negation involves only scalar values or variables and is equivalent to complementing the operator:

```rego
t :- 42 = x, not x = "the meaning of life"
```

The result:

```
t
# true
```

Negation is required to check whether some value *does not* exist in a
collection. I.e., complementing the operator in an expression such as `p[_] =
"foo"` yields `p[_] != "foo"`, however, this is not equivalent to `not p["foo"]`.

For example, we can write a rule that defines a document containing names of
apps not deployed on the "prod" site:

```rego
not_in_production[name] :-
    apps[i].name = name,
    not prod_server_names[name]

prod_server_names[name] :-
    sites[i].name = "prod",
    sites[i].servers[_].name = name
```

The result:

```
not_in_production
# ["mongodb"]
```

## Modules

In Rego, policies are defined inside *modules*. Modules consist of:

- Exactly one [Package](#packages) declaration.
- Zero or more [Import](#imports) statements.
- Zero or more [Rule](#rules) definitions.

Modules are typically represented in Unicode text and encoded in UTF-8.

### <a name="comments"></a> Comments

Comments begin with the `#` character and continue until the end of the line.

### <a name="packages"></a> Packages

Packages group the rules defined in one or more modules into a particular
namespace. Because rules are namespaced they can be safely shared across
projects.

Modules contributing to the same package do not have to be located in the same
directory.

The rules defined in a module are automatically exported. I.e., they can be
queried under OPA's [Data API](CONCEPTS.md#data-api) provided the appropriate
package is given, e.g., given the following module:

```rego
package opa.examples

pi = 3.14159
```

The "pi" document can be queried via the Data API:

```
GET /v1/data/opa/examples/pi
```

### <a name="imports"></a> Imports

Import statements declare dependencies that modules have on documents
defined outside the package. By importing a document, the identifiers
exported by that document can be referenced within the current module.

All modules contain an implicit statement which imports the "data" document.

Modules use the same syntax to declare dependencies on [Base
Documents](./CONCEPTS.md#data-model) and [Virtual
Documents](./CONCEPTS.md#data-model).

```rego
package opa.examples

import data.servers

http_servers[server] :-
    server = servers[_]
    server.protocols[_] = "http"
```

Imports can include an optional `alias` statement to handle namespacing
issues:

```rego
package opa.examples

import data.servers as my_servers

http_servers[server] :-
    server = my_servers[_]
    server.protocols[_] = "http"
```

## <a name="operators"></a> Operators

### <a name="equality"></a> Equality

The equality operator (`=`) is used to define expressions that assert that
two values are the same. If the expression is defined in terms of one or more
variables then the expression will evaluate to true if one of the variables is
unbound. If the neither operand is an unbound variable, the expression is
evaluated by comparing the *values* referenced by the operands.

OPA attempts to *bind* variables to values when it encounters unbound variables
in equality expressions. Binding a variable affects subsequent evaluation of
expressions such that the variable will be treated as a constant (with the
bound value) instead of a variable.

### <a name="inequality"></a> Inequality

The following inequality operators are supported:

| Symbol | Example | Description |
| --- | --- | --- |
| `!=` | `"foo" != x.y` | Returns true if the left hand side does not equal the right hand side, false otherwise. |
| `<` | `"foo" < x.y` | Returns true if the left hand side is less than the right hand side, false otherwise. |
| `>` | `"foo" > x.y` | Returns true if the left hand side is greater than the right hand side, false otherwise. |
| `>=` | `"foo" >= x.y` | Returns true if the left hand side is less than or equal to the right hand side, false otherwise. |
| `<=` | `"foo" <= x.y` | Returns true if the left hand side is greater than or equal to the right hand side, false otherwise. |

If either operand is a variable, the variable must appear in a non-negated
equality expression within the same rule.

## <a name="examples"></a> Examples

The rules below define the content of two documents describing a simplistic
deployment environment. These documents are referenced in other sections
above. If you are experimenting with OPA, you can copy-paste the content below
into an OPA CLI session and reference it when following along above.

```rego
sites :- [
    {
        "region": "east",
        "name": "prod",
        "servers": [
            {
                "name": "web-0",
                "hostname": "hydrogen"
            },
            {
                "name": "web-1",
                "hostname": "helium"
            },
            {
                "name": "db-0",
                "hostname": "lithium"
            }
        ]
    },
    {
        "region": "west",
        "name": "smoke",
        "servers": [
            {
                "name": "web-1000",
                "hostname": "berylium"
            },
            {
                "name": "web-1001",
                "hostname": "boron"
            },
            {
                "name": "db-1000",
                "hostname": "carbon"
            }
        ]
    },
    {
        "region": "west",
        "name": "dev",
        "servers": [
            {
                "name": "web-dev",
                "hostname": "nitrogen"
            },
            {
                "name": "db-dev",
                "hostname": "oxygen"
            }
        ]
    }
]

apps :- [
    {
        "name": "web",
        "servers": ["web-0", "web-1", "web-1000", "web-1001", "web-dev"]
    },
    {
        "name": "mysql",
        "servers": ["db-0", "db-1000"]
    },
    {
        "name": "mongodb",
        "servers": ["db-dev"]
    }
]

containers :- [
    {
        "image": "redis",
        "ipaddress": "10.0.0.1",
        "name": "big_stallman"
    },
    {
        "image": "nginx",
        "ipaddress": "10.0.0.2",
        "name": "cranky_euclid"
    }
]
```

## <a name="grammar"></a> Rego Grammar

Rego's syntax is defined by the following grammar:

```
module         = package { import } policy
package        = "package" ref
import         = "import" package [ "as" var ]
policy         = { rule }
rule           = rule-head [ ":-" rule-body ]
rule-head      = var [ "[" var "]" ] [ = term ]
rule-body      = [ literal { "," literal } ]
literal        = expr | "not" expr
expr           = term | expr-builtin | expr-infix
expr-builtin   = var "(" [ term { , term } ] ")"
expr-infix     = term bool-operator term
term           = ref | var | scalar | array | object
bool-operator  = "=" | "!=" | "<" | ">" | ">=" | "<="
ref            = var { ref-arg }
ref-arg        = ref-arg-dot | ref-arg-brack
ref-arg-brack  = "[" ( scalar | var | "_" ) "]"
ref-arg-dot    = "." var
var            = ALPHA { ALPHA | DIGIT | "_" }
scalar         = STRING | NUMBER | TRUE | FALSE | NULL
array          = "[" term { "," term } "]"
object         = "{" object-item { "," object-item } "}"
object-item    = ( scalar | ref | var ) ":" term
```

The grammar defined above makes use of the following syntax. See [the Wikipedia page on EBNF](https://en.wikipedia.org/wiki/Extended_Backusâ€“Naur_Form) for more details:

```
[]     optional (zero or one instances)
{}     repetition (zero or more instances)
|      alteration (one of the instances)
()     grouping (order of expansion)
STRING JSON string
NUMBER JSON number
TRUE   JSON true
FALSE  JSON false
NULL   JSON null
ALPHA  ASCII characters A-Z and a-z
DIGIT  ASCII characters 0-9
```
