go test fuzz v1
string("package test\n\nimport data.ex\n\nbasic = true { ex.loopback = true with input as true; ex.loopback = false with input as false }\nnegation = true { not ex.loopback with input as false; ex.loopback with input as true }\ncomposite[x] { ex.composite[x] with input.foo as [1, 2, 3, 4] }\nvars = x { foo = \"hello\"; bar = \"world\"; x = ex.vars with input.foo as foo with input.bar as bar }\nconflict = true { ex.loopback with input.foo as \"x\" with input.foo.bar as \"y\" }\nnegation_invalidate[x] { data.a[_] = x; not data.ex.input_eq with input.x as x }\nbasic_data = true {ex.allow_basic = true with data.a as \"testdata\"}\nmap_data_1 = true {ex.allow_merge_1 = true with data.b.v2 as \"world\"}\nmap_data_2 = true {ex.allow_merge_2 = true with data.b.v2 as \"world\" with data.b.v3 as \"again\"}\ndata_conflict = true {ex.allow_basic = true with data.a.b as 5}\nbase_doc_exact_value[x] { data.a.b[x] = 1 with data.a.b as {\"c\": 1, \"d\": 2, \"e\": 1} }\nbase_doc_any_index[x] { data.a.b[x] with data.a.b as {\"c\": 1, \"d\": 2, \"e\": 1} }\nundefined_1 { data.a.b.c with data.a.b as 1 }\nundefined_2 { data.l.a with data.l as 1 }\nvirtual_doc_exact_value[x] { ex.virtual = x with data.a.b as {\"c\": 1, \"d\": 2, \"e\": 1} }\nvirtual_doc_any_index[x] { ex.virtual[x] with data.a.b as {\"c\": 1, \"d\": 2, \"e\": 1} }\nvirtual_doc_specific_index = y { y = ex.virtual[\"c\"] with data.a.b as {\"c\": 1, \"d\": 2, \"e\": 1} }\nvirtual_doc_not_specific_index = true { not ex.virtual[\"d\"] with data.a.b as {\"c\": 1, \"d\": 2, \"e\": 1} }\ntest_mock_var = y {y = ex.mock_var with ex.mock_var as {\"c\": 1, \"d\": 2}}\ntest_mock_rule {ex.mock_rule with ex.mock_rule as true}\ntest_rule_chain {ex.allow with data.label.b.c as [1,2,3]}\n")
